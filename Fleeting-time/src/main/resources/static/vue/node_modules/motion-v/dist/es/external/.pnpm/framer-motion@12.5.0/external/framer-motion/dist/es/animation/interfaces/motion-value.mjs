import { GroupPlaybackControls } from "../../../../../../../motion-dom@12.5.0/external/motion-dom/dist/es/animation/controls/Group.mjs";
import { getValueTransition } from "../../../../../../../motion-dom@12.5.0/external/motion-dom/dist/es/animation/utils/get-value-transition.mjs";
import "../../../../../../../motion-utils@12.5.0/external/motion-utils/dist/es/errors.mjs";
import { secondsToMilliseconds } from "../../../../../../../motion-utils@12.5.0/external/motion-utils/dist/es/time-conversion.mjs";
import { frame } from "../../../../../../../motion-dom@12.5.0/external/motion-dom/dist/es/frameloop/frame.mjs";
import { AcceleratedAnimation } from "../animators/AcceleratedAnimation.mjs";
import { MainThreadAnimation } from "../animators/MainThreadAnimation.mjs";
import { getFinalKeyframe } from "../animators/waapi/utils/get-final-keyframe.mjs";
import { getDefaultTransition } from "../utils/default-transitions.mjs";
import { isTransitionDefined } from "../utils/is-transition-defined.mjs";
const animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {
  const valueTransition = getValueTransition(transition, name) || {};
  const delay = valueTransition.delay || transition.delay || 0;
  let { elapsed = 0 } = transition;
  elapsed = elapsed - secondsToMilliseconds(delay);
  let options = {
    keyframes: Array.isArray(target) ? target : [null, target],
    ease: "easeOut",
    velocity: value.getVelocity(),
    ...valueTransition,
    delay: -elapsed,
    onUpdate: (v) => {
      value.set(v);
      valueTransition.onUpdate && valueTransition.onUpdate(v);
    },
    onComplete: () => {
      onComplete();
      valueTransition.onComplete && valueTransition.onComplete();
    },
    name,
    motionValue: value,
    element: isHandoff ? void 0 : element
  };
  if (!isTransitionDefined(valueTransition)) {
    options = {
      ...options,
      ...getDefaultTransition(name, options)
    };
  }
  if (options.duration) {
    options.duration = secondsToMilliseconds(options.duration);
  }
  if (options.repeatDelay) {
    options.repeatDelay = secondsToMilliseconds(options.repeatDelay);
  }
  if (options.from !== void 0) {
    options.keyframes[0] = options.from;
  }
  let shouldSkip = false;
  if (options.type === false || options.duration === 0 && !options.repeatDelay) {
    options.duration = 0;
    if (options.delay === 0) {
      shouldSkip = true;
    }
  }
  options.allowFlatten = !valueTransition.type && !valueTransition.ease;
  if (shouldSkip && !isHandoff && value.get() !== void 0) {
    const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);
    if (finalKeyframe !== void 0) {
      frame.update(() => {
        options.onUpdate(finalKeyframe);
        options.onComplete();
      });
      return new GroupPlaybackControls([]);
    }
  }
  if (!isHandoff && AcceleratedAnimation.supports(options)) {
    return new AcceleratedAnimation(options);
  } else {
    return new MainThreadAnimation(options);
  }
};
export {
  animateMotionValue
};
